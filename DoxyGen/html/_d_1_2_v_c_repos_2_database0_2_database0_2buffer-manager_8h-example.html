<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MiniSQL: D:/VCRepos/Database0/Database0/buffer-manager.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MiniSQL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_d_1_2_v_c_repos_2_database0_2_database0_2buffer-manager_8h-example.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">D:/VCRepos/Database0/Database0/buffer-manager.h</div>  </div>
</div><!--header-->
<div class="contents">
<p>insert data </p><dl class="section return"><dt>Returns</dt><dd>false if space is not enough, no data will be inserted! </dd>
<dd>
true if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>the pointing to begining of data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last of data</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"> {c++}</div><div class="line">Iterator&lt;int&gt; itr; <span class="keywordtype">int</span> data[10]</div><div class="line">itr.Insert(data, data + 10); <span class="comment">// insert 10 element</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> a;</div><div class="line">itr.Insert(&amp;a, &amp;a + 1); <span class="comment">// insert 1 element</span></div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div><div class="line"><span class="comment">// #define _HAS_CXX17 1</span></div><div class="line"><span class="preprocessor">#include &lt;memory.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;exception&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;experimental/filesystem&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>fs = std::experimental::filesystem;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> UnderlyingType, <span class="keywordtype">int</span> StrongType&gt;</div><div class="line"><span class="keyword">struct </span><a name="_a0"></a><a class="code" href="struct_generic_i_o_id.html">GenericIOId</a> {</div><div class="line">    <span class="keyword">using</span> IdType = UnderlyingType;</div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">GenericIOId</a>(UnderlyingType t) : id(t) {}</div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">GenericIOId</a>() : id(0) {}</div><div class="line"></div><div class="line">    enum : UnderlyingType {</div><div class="line">        kMax = std::numeric_limits&lt;UnderlyingType&gt;::max()</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">operator</span> UnderlyingType() {</div><div class="line">        <span class="keywordflow">return</span> id;</div><div class="line">    }</div><div class="line"></div><div class="line">    UnderlyingType id;</div><div class="line">    <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> <a class="code" href="struct_generic_i_o_id.html">GenericIOId</a>&amp; rhs)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> <span class="keywordtype">id</span> &lt; rhs.<a name="a1"></a>id;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="struct_generic_i_o_id.html">GenericIOId</a>&amp; rhs)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> <span class="keywordtype">id</span> == rhs.id;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> <a class="code" href="struct_generic_i_o_id.html">GenericIOId</a>&amp; rhs)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> !operator==(rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> <a class="code" href="struct_generic_i_o_id.html">GenericIOId</a>&amp; rhs)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span>  <span class="keywordtype">id</span> &gt; rhs.id;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Inc() {</div><div class="line">        ++id;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> IsNil() { <span class="keywordflow">return</span> <span class="keywordtype">id</span> == 0; }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="struct_generic_i_o_id.html">PageId</a> = <a name="_a2"></a><a class="code" href="struct_generic_i_o_id.html">GenericIOId&lt;uint32_t, 1&gt;</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="struct_generic_i_o_id.html">FileId</a> = <a name="_a3"></a><a class="code" href="struct_generic_i_o_id.html">GenericIOId&lt;uint16_t, 0&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#define PAGE_SIZE_BY_BYTES 16 * 1024</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span><a name="_a4"></a><a class="code" href="struct_variadic.html">Variadic</a> {</div><div class="line">    <span class="keywordtype">char</span> placeholder;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span><a name="_a5"></a><a class="code" href="struct_page.html">Page</a> {</div><div class="line">    <span class="keyword">struct </span>Header {</div><div class="line">        <span class="keywordtype">int</span> prev = 0; <span class="comment">// OFFSET of previous page</span></div><div class="line">        <span class="keywordtype">int</span> next = 0;</div><div class="line">        uint16_t num_records = 0;</div><div class="line">        uint16_t flags = 0;</div><div class="line">        uint16_t free_offset = 0;</div><div class="line">        uint64_t log_sqn = 0;     <span class="comment">// log sequence number</span></div><div class="line">        <span class="keywordtype">void</span> set_flag(<span class="keywordtype">int</span> i) {</div><div class="line">            flags |= 1 &lt;&lt; i;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> clear_flag(<span class="keywordtype">int</span> i) {</div><div class="line">            flags &amp;= ~(1 &lt;&lt; i);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> flag(<span class="keywordtype">int</span> i) {</div><div class="line">            <span class="keywordflow">return</span> flags &amp; (1 &lt;&lt; i);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">enum</span> {</div><div class="line">        kPageSize = PAGE_SIZE_BY_BYTES,</div><div class="line">        kDiscretionSpace = kPageSize - <span class="keyword">sizeof</span>(Header),</div><div class="line">        kInValidOffset = UINT16_MAX,</div><div class="line">        kBeginOfReversed = kDiscretionSpace - 1,</div><div class="line"></div><div class="line">        kfIsVariadic = 0, <span class="comment">// denotes this page is variadic</span></div><div class="line">        kfExtendToNext = 1, <span class="comment">// whether the last data extend</span></div><div class="line">        kfIsUnused = 2</div><div class="line">    };</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">struct </span>DataPos {</div><div class="line">        uint16_t length;</div><div class="line">        uint16_t offset;</div><div class="line">    };</div><div class="line"></div><div class="line">    static_assert(<span class="keyword">alignof</span>(Header) == <span class="keyword">alignof</span>(uint64_t), <span class="stringliteral">&quot;Header Must be aligned to max so that it can match any data&#39;s align requirement&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keywordtype">void</span> Write(<span class="keywordtype">size_t</span> offset, T data) {</div><div class="line">        *(static_cast&lt;T*&gt;(space) + offset) = data;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    void ReverseWriteBit(int offset, bool data) {</span></div><div class="line"><span class="comment">        int char_of_bit = offset/ 8 + 1;</span></div><div class="line"><span class="comment">        int offset_in_char = 7 - offset % 8;</span></div><div class="line"><span class="comment">        char&amp; target = end()[-char_of_bit];</span></div><div class="line"><span class="comment">        unsigned char mask = 1 &lt;&lt; offset_in_char;</span></div><div class="line"><span class="comment">        if (data) {</span></div><div class="line"><span class="comment">            target |= mask;</span></div><div class="line"><span class="comment">        }</span></div><div class="line"><span class="comment">        else {</span></div><div class="line"><span class="comment">            target &amp;= ~mask;</span></div><div class="line"><span class="comment">        }</span></div><div class="line"><span class="comment">    }</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    bool ReverseReadBit(int offset) {</span></div><div class="line"><span class="comment">        int char_of_bit = offset / 8 + 1;</span></div><div class="line"><span class="comment">        int offset_in_char = 7 - offset % 8;</span></div><div class="line"><span class="comment">        char target = end()[-char_of_bit];</span></div><div class="line"><span class="comment">        unsigned char mask = 1 &lt;&lt; offset_in_char;</span></div><div class="line"><span class="comment">        return target &amp; ~mask;</span></div><div class="line"><span class="comment">    }*/</span></div><div class="line">    </div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keywordtype">void</span> ReverseInsertN(<span class="keywordtype">size_t</span> src_offet, <span class="keywordtype">size_t</span> num_vals, <span class="keywordtype">size_t</span> move_size, T val) {</div><div class="line">        <span class="keyword">auto</span> t = reinterpret_cast&lt;T*&gt;(end());</div><div class="line">        <span class="keywordtype">size_t</span> dst_offset = num_vals + src_offet;</div><div class="line">        <span class="comment">// memmove(t - src_offet - move_size, t - dst_offset - move_size, move_size * sizeof(T));</span></div><div class="line">        memmove(t - dst_offset - move_size, t - src_offet - move_size, move_size * <span class="keyword">sizeof</span>(T));</div><div class="line">        std::fill_n(t - dst_offset, num_vals, val);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keywordtype">void</span> ReverseEraseN(<span class="keywordtype">size_t</span> src_offet, <span class="keywordtype">size_t</span> num_vals, <span class="keywordtype">size_t</span> move_size) {</div><div class="line">        <span class="keyword">auto</span> t = reinterpret_cast&lt;T*&gt;(end());</div><div class="line">        <span class="keywordtype">size_t</span> dst_offset = src_offet - num_vals;</div><div class="line">        memmove(t - src_offet - move_size, t - dst_offset - move_size, move_size * <span class="keyword">sizeof</span>(T));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    T Read(<span class="keywordtype">size_t</span> offset)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> *(reinterpret_cast&lt;T*&gt;(space) + offset);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    T&amp; Read(<span class="keywordtype">size_t</span> offset) {</div><div class="line">        <span class="keywordflow">return</span> *(reinterpret_cast&lt;T*&gt;(space) + offset);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    T&amp; ReverseRead(<span class="keywordtype">size_t</span> offset) {</div><div class="line">        <span class="keywordflow">return</span> *(reinterpret_cast&lt;T*&gt;(end()) - offset - 1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    T ReverseRead(<span class="keywordtype">size_t</span> offset)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> *(reinterpret_cast&lt;T*&gt;(end()) - offset - 1);</div><div class="line">    }</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> SpaceLeftByByte() {</div><div class="line">        <span class="keywordtype">char</span>* begin_of_free = space + kBeginOfReversed - header.<a name="a6"></a>free_offset;</div><div class="line">        <span class="keywordflow">if</span> (header.<a name="a7"></a>flag(kfIsVariadic)) {</div><div class="line">            <span class="keywordtype">char</span>* end_of_free = space + header.<a name="a8"></a>num_records * <span class="keyword">sizeof</span>(DataPos);</div><div class="line">            <span class="keywordflow">return</span> begin_of_free - end_of_free;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> {</div><div class="line">            <span class="keywordtype">char</span>* end_of_free = space + (header.num_records + 7) / 8;</div><div class="line">            <span class="keywordflow">return</span> begin_of_free - end_of_free;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> SpaceLeftByByteFixedSize()<span class="keyword"> const </span>{</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* begin_of_free = space + header.free_offset;</div><div class="line">        <span class="comment">// num_records bits of null table, we round it up to char</span></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* end_of_free = end() -  (header.num_records + 7) / 8 * 8;</div><div class="line">        <span class="keywordflow">return</span> begin_of_free - end_of_free;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> SpaceLeftByByteVariadicSize()<span class="keyword"> const </span>{</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* begin_of_free = space + kDiscretionSpace - header.free_offset;</div><div class="line">        <span class="comment">// num_records bits of null table, we round it up to char</span></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* end_of_free = space + header.num_records  * <span class="keyword">sizeof</span>(DataPos);</div><div class="line">        <span class="keywordflow">return</span> begin_of_free - end_of_free;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> HasPrev()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> header.<a name="a9"></a>prev != 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> HasNext()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> header.<a name="a10"></a>next != 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">char</span>* end() {</div><div class="line">        <span class="keywordflow">return</span> space + kDiscretionSpace;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* end()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> space + kDiscretionSpace;</div><div class="line">    }</div><div class="line"></div><div class="line">    Header header;</div><div class="line">    <span class="keywordtype">char</span> space[kDiscretionSpace];</div><div class="line"></div><div class="line">    <span class="comment">// extra info not written to disk</span></div><div class="line">    <span class="keywordtype">bool</span> is_dirty = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordtype">void</span>* piggyback = <span class="keyword">nullptr</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> Page::Write&lt;bool&gt;(<span class="keywordtype">size_t</span> offset, <span class="keywordtype">bool</span> data) {</div><div class="line">    <span class="keywordtype">size_t</span> char_of_bit = offset / 8;</div><div class="line">    <span class="keywordtype">size_t</span> offset_in_char = offset % 8;</div><div class="line">    <span class="keywordtype">char</span>&amp; target = space[char_of_bit];</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask = 1 &lt;&lt; offset_in_char;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (data) {</div><div class="line">        target |= mask;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        target &amp;= ~mask;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> Page::Read&lt;bool&gt;(<span class="keywordtype">size_t</span> offset)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordtype">size_t</span> char_of_bit = offset / 8;</div><div class="line">    <span class="keywordtype">size_t</span> offset_in_char = offset % 8;</div><div class="line">    <span class="keywordtype">char</span> target = space[char_of_bit];</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask = 1 &lt;&lt; offset_in_char;</div><div class="line">    <span class="keywordflow">return</span> target &amp; ~mask;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">class </span><a name="_a11"></a><a class="code" href="class_buffer_manager.html">BufferManager</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keyword">class </span>Iterator {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">using</span> pointer = T *;</div><div class="line">        Iterator(T* current, <a class="code" href="struct_page.html">Page</a>* <a name="a12"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a5a17d8377bc10f437e29b058c0376b15">page</a>, <a class="code" href="class_buffer_manager.html">BufferManager</a>* boss)</div><div class="line">            :current_(current), page_(<a class="code" href="class_buffer_manager_1_1_iterator.html#a5a17d8377bc10f437e29b058c0376b15">page</a>), boss_(boss), record_in_page_(0) {}</div><div class="line"></div><div class="line">        Iterator(T* current, <a class="code" href="struct_page.html">Page</a>* <a class="code" href="class_buffer_manager_1_1_iterator.html#a5a17d8377bc10f437e29b058c0376b15">page</a>, <a class="code" href="class_buffer_manager.html">BufferManager</a>* boss, uint16_t record_in_page)</div><div class="line">            :current_(current), page_(<a class="code" href="class_buffer_manager_1_1_iterator.html#a5a17d8377bc10f437e29b058c0376b15">page</a>), boss_(boss), record_in_page_(record_in_page) {}</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> <a name="a13"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#ad19030c51bf30e6d6e9e2e560cc511c4">IsNil</a>()<span class="keyword"> const </span>{</div><div class="line">            <span class="keywordflow">return</span> page_-&gt;<a name="a14"></a>ReverseRead&lt;<span class="keywordtype">char</span>&gt;(record_in_page_);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> <a name="a15"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a6afaceac9683f05d9e1ecfc9ff5f3a0f">IsEndPage</a>()<span class="keyword"> const </span>{</div><div class="line">            <span class="keywordflow">return</span> (record_in_page_ == page_-&gt;<a name="a16"></a>header.num_records);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> <a name="a17"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a02a38a84fd54e45d06818d2807b172d8">IsEnd</a>()<span class="keyword"> const </span>{</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="class_buffer_manager_1_1_iterator.html#a6afaceac9683f05d9e1ecfc9ff5f3a0f">IsEndPage</a>()  <span class="comment">// we reach end of the page</span></div><div class="line">                &amp;&amp; !page_-&gt;<a name="a18"></a>HasNext(); <span class="comment">// and page does not have any nexts</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> <a name="a19"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a7ce4145bd6263f8003c4c4dee01a9c31">IsBegin</a>()<span class="keyword"> const </span>{</div><div class="line">            <span class="keywordflow">return</span> (record_in_page_ == 0)  <span class="comment">// we reach end of the page</span></div><div class="line">                &amp;&amp; !page_-&gt;<a name="a20"></a>HasPrev(); <span class="comment">// and page does not have any prevs</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="struct_generic_i_o_id.html">PageId</a> <a name="a21"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#affb973bacb2deef1704e20221fb3c3fb">InsertPageAfter</a>();</div><div class="line"></div><div class="line">        Iterator&amp; <a name="a22"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#aabf5af4d55b46c14bddff0e7caab3665">operator++</a>(); <span class="comment">// prefix</span></div><div class="line"></div><div class="line">        [[deprecated(<span class="stringliteral">&quot;Please use prefix version as this is less efficient&quot;</span>)]]</div><div class="line">        Iterator <a class="code" href="class_buffer_manager_1_1_iterator.html#aabf5af4d55b46c14bddff0e7caab3665">operator++</a>(<span class="keywordtype">int</span>); <span class="comment">// postfix</span></div><div class="line"></div><div class="line">        Iterator&amp; <a name="a23"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#ab9959f549dcfa3f6daa47677552b673d">operator--</a>();</div><div class="line"></div><div class="line">        [[deprecated(<span class="stringliteral">&quot;Please use prefix version as this is less efficient&quot;</span>)]]</div><div class="line">        Iterator <a class="code" href="class_buffer_manager_1_1_iterator.html#ab9959f549dcfa3f6daa47677552b673d">operator--</a>(<span class="keywordtype">int</span>);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> Iterator&amp; <a name="a24"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#aced12f95569a91d98a83bf635d671e25">operator+=</a>(<span class="keywordtype">int</span> offset);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> Iterator&amp; <a name="a25"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a2a24e019d3a2934f3cd275b8a2436e59">operator-=</a>(<span class="keywordtype">int</span> offset);</div><div class="line"></div><div class="line">        <span class="comment">//TODO(L) Assert</span></div><div class="line"><span class="comment"></span>        T&amp; <a name="a26"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a633c54abf71a334ff179cc359e655d5d">operator*</a>() { <span class="comment">/*if (IsEndPage()) { ++* this; }*/</span>  <span class="keywordflow">return</span> *current_; }</div><div class="line"></div><div class="line">        T* operator-&gt;() { <span class="keywordflow">return</span> current_; }</div><div class="line">        </div><div class="line">        <span class="keyword">const</span> T&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#a633c54abf71a334ff179cc359e655d5d">operator*</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *current_; }</div><div class="line">        </div><div class="line">        <span class="keyword">const</span> T* operator-&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> current_; }</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="struct_page.html">Page</a>&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#a5a17d8377bc10f437e29b058c0376b15">page</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *page_; }</div><div class="line"></div><div class="line">        <span class="keywordtype">size_t</span> <a name="a27"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a436c0bafa40d441a59c0fb0e3aeb62cc">FreeSlots</a>()<span class="keyword"> const </span>{</div><div class="line">            <span class="keywordflow">return</span> page_-&gt;<a name="a28"></a>SpaceLeftByByteFixedSize() / (<span class="keyword">sizeof</span>(T) * step_ + <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">size_t</span> <a name="a29"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a3a53f35f35074aa2079dead6cc606a5b">FreeBytes</a>()<span class="keyword"> const </span>{</div><div class="line">            <span class="keywordflow">return</span> page_-&gt;SpaceLeftByByteFixedSize();</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="struct_generic_i_o_id.html">PageId</a> <a name="a30"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a7a57002c7f8daa714cf9e19e34874fca">pageid</a>() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> Insert(<span class="keyword">const</span> T* first, <span class="keyword">const</span> T* last) {</div><div class="line">            uint16_t num_elem = static_cast&lt;uint16_t&gt;(last - first);</div><div class="line">            <span class="keywordflow">if</span> (num_elem &gt; <a class="code" href="class_buffer_manager_1_1_iterator.html#a436c0bafa40d441a59c0fb0e3aeb62cc">FreeSlots</a>()) {</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            uint16_t defacto_num_elem = num_elem / step_;</div><div class="line"></div><div class="line">            <span class="keywordtype">size_t</span> n_moved = page_-&gt;header.num_records - record_in_page_;</div><div class="line">            page_-&gt;header.free_offset += static_cast&lt;uint16_t&gt;(num_elem * <span class="keyword">sizeof</span>(T));</div><div class="line">            memmove(current_ + num_elem, current_, n_moved * step_ * <span class="keyword">sizeof</span>(T));</div><div class="line">            memmove(current_, first, num_elem * <span class="keyword">sizeof</span>(T));</div><div class="line"></div><div class="line">            page_-&gt;<a name="a31"></a>ReverseInsertN&lt;<span class="keywordtype">char</span>&gt;(record_in_page_, defacto_num_elem, n_moved, (char)0);</div><div class="line">            page_-&gt;header.num_records += defacto_num_elem;</div><div class="line"></div><div class="line">            page_-&gt;<a name="a32"></a>is_dirty = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> Insert(T val) {</div><div class="line">            <span class="keywordflow">return</span> Insert(&amp;val, &amp;val + 1);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> <a name="a33"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a2c627998f19999fe55b7452b840ce47b">EraseInPage</a>(<span class="keywordtype">size_t</span> n = 1) {</div><div class="line">            uint16_t num_elem = n * step_;</div><div class="line">            int32_t n_moved = page_-&gt;header.num_records - record_in_page_ - num_elem;</div><div class="line">            <span class="keywordflow">if</span> (n_moved &lt;= 0) {</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">            page_-&gt;header.free_offset -= num_elem * <span class="keyword">sizeof</span>(T);</div><div class="line">            memmove(current_, current_ + num_elem, n_moved * step_ * <span class="keyword">sizeof</span>(T));</div><div class="line">            </div><div class="line">            page_-&gt;<a name="a34"></a>ReverseEraseN&lt;T&gt;(record_in_page_, n, n_moved);</div><div class="line">            page_-&gt;header.num_records -= n;</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> <a name="a35"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a2e9a59db2ef1289b16469750e422edd5">DeletePage</a>();</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> Insert(Iterator first, Iterator last) {</div><div class="line">            Iterator old_first = first;</div><div class="line">            <span class="keyword">auto</span> slots = <a class="code" href="class_buffer_manager_1_1_iterator.html#a436c0bafa40d441a59c0fb0e3aeb62cc">FreeSlots</a>();</div><div class="line">            uint16_t count = 0;</div><div class="line">            <span class="keywordflow">while</span> (first.pageid() != last.pageid()) {</div><div class="line">                Iterator first_endpage = first;</div><div class="line">                first_endpage.MoveToPageEnd();</div><div class="line">                count += first_endpage.current_ - first.current_;</div><div class="line">                <span class="keywordflow">if</span> (count &gt; slots) {</div><div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">                first = ++first_endpage;</div><div class="line">            }</div><div class="line">            count += last.current_ - first.current_;</div><div class="line">            <span class="keywordflow">if</span> (count &gt; slots) {</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            first = old_first;</div><div class="line">            <span class="keywordflow">while</span> (first.pageid() != last.pageid()) {</div><div class="line">                Iterator first_endpage = first;</div><div class="line">                first_endpage.MoveToPageEnd();</div><div class="line">                <span class="keyword">auto</span> res = Insert(first.current_, first_endpage.current_);</div><div class="line">                <span class="keywordflow">if</span> (!res) {</div><div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">                first = ++first_endpage;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> Insert(first.current_, last.current_);</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> <a name="a36"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a20b703d6135c5e3026eab944a32ca186">MoveToPageCenter</a>() {</div><div class="line">            <span class="keywordtype">int</span> target = record_in_page_ - page_-&gt;header.num_records / 2;</div><div class="line">            <span class="keywordflow">while</span> (target &gt; 0) {</div><div class="line">                --* <span class="keyword">this</span>;</div><div class="line">                --target;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">while</span> (target &lt; 0) {</div><div class="line">                ++* <span class="keyword">this</span>;</div><div class="line">                ++target;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> <a name="a37"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a88ae36356076d25c8959ecfbaa084d9f">MoveToPageEnd</a>() {</div><div class="line">            record_in_page_ = page_-&gt;header.num_records;</div><div class="line">            current_ = reinterpret_cast&lt;T*&gt;(page_-&gt;<a name="a38"></a>space + page_-&gt;header.free_offset);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> <a name="a39"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a5fcb5fb10746e3d58736959a12610dd0">MoveToPageBegin</a>() {</div><div class="line">            record_in_page_ = 0;</div><div class="line">            current_ = reinterpret_cast&lt;T*&gt;(page_-&gt;space);</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="struct_generic_i_o_id.html">PageId</a> <a name="a40"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#a18f31d37240c5a587a85042374c5272d">SplitPage</a>() {</div><div class="line">            <span class="keyword">auto</span> piggy = reinterpret_cast&lt;PagePiggyback*&gt;(page_-&gt;<a name="a41"></a>piggyback);</div><div class="line">            </div><div class="line">            <a class="code" href="struct_generic_i_o_id.html">PageId</a> pid = boss_-&gt;<a name="a42"></a>AllocatePageAfter(piggy-&gt;finfo-&gt;id, piggy-&gt;page_id);</div><div class="line">            Iterator next = boss_-&gt;<a name="a43"></a>GetPage&lt;T&gt;(piggy-&gt;finfo-&gt;id, pid);</div><div class="line">            next.step_ = step_;</div><div class="line">            int16_t moved_size = static_cast&lt;uint16_t&gt;((page_-&gt;header.num_records - record_in_page_) * step_);</div><div class="line">            next.Insert(current_, current_ + moved_size);</div><div class="line">            page_-&gt;header.num_records = record_in_page_;</div><div class="line">            page_-&gt;header.free_offset -= moved_size;</div><div class="line">            <span class="keywordflow">return</span> pid;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> <a name="a44"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#aee5637c96ddb7c5fef0f9a12d133c7c8">InsertNil</a>(uint16_t n) {</div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="class_buffer_manager_1_1_iterator.html#a3a53f35f35074aa2079dead6cc606a5b">FreeBytes</a>() &lt; n) {</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">            <span class="keywordtype">size_t</span> n_moved = page_-&gt;header.num_records - record_in_page_;</div><div class="line">            page_-&gt;ReverseInsertN&lt;<span class="keywordtype">char</span>&gt;(record_in_page_, n, n_moved, (char)1);</div><div class="line">            page_-&gt;header.num_records += n;</div><div class="line">            page_-&gt;is_dirty = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> SetStep(uint16_t step) {</div><div class="line">            step_ = step;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">//TODO(L): assert if uncastable (i.e. misaligned data)</span></div><div class="line"><span class="comment"></span>        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</div><div class="line">        Iterator&lt;U&gt; <a name="a45"></a><a class="code" href="class_buffer_manager_1_1_iterator.html#aac3b1b6e41babe5e82814e69e040fd20">Cast</a>(Iterator t) {</div><div class="line">            <span class="keywordflow">return</span> Iterator&lt;U&gt;(reinterpret_cast&lt;U*&gt;(current_), page_, boss_, record_in_page_);</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="class_buffer_manager.html">BufferManager</a>;</div><div class="line">        T* current_;</div><div class="line">        <a class="code" href="struct_page.html">Page</a>* page_;</div><div class="line">        <a class="code" href="class_buffer_manager.html">BufferManager</a>* boss_;</div><div class="line">        uint16_t record_in_page_;</div><div class="line">        uint16_t step_ = 1;</div><div class="line">    };</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">    <span class="keyword">struct </span>UniquePage {</div><div class="line">        <a class="code" href="struct_generic_i_o_id.html">PageId</a> page;</div><div class="line">        <a class="code" href="struct_generic_i_o_id.html">FileId</a> file;</div><div class="line">        <span class="keyword">mutable</span> uint16_t use_count;</div><div class="line">        <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> UniquePage&amp; rhs)<span class="keyword"> const </span>{ </div><div class="line">            <span class="keywordflow">if</span> (file &lt; rhs.file) {</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (file &gt; rhs.file) {</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> page &lt; rhs.page;</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>FileHeader {</div><div class="line">        <span class="keywordtype">char</span> magic[4] = <span class="stringliteral">&quot;HMG&quot;</span>;</div><div class="line">        uint64_t num_pages = 0;</div><div class="line">        <a class="code" href="struct_generic_i_o_id.html">PageId</a> first_free = 0;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>FileInfo {</div><div class="line">        <span class="keywordtype">void</span>* fd; <span class="comment">//&lt; file descriptor</span></div><div class="line">        <a class="code" href="struct_generic_i_o_id.html">FileId</a> id;</div><div class="line">        std::string abs_path;</div><div class="line">        FileHeader header;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PagePiggyback {</div><div class="line">        FileInfo *finfo;</div><div class="line">        <a class="code" href="struct_generic_i_o_id.html">PageId</a> page_id;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> IsOpened(<span class="keyword">const</span> <span class="keywordtype">char</span>* path);</div><div class="line"></div><div class="line">    <span class="comment">// @throws std::ios_base::failure if path not exits</span></div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">FileId</a> OpenFile(<span class="keyword">const</span> <span class="keywordtype">char</span>* path);</div><div class="line"></div><div class="line">    <span class="comment">// create a formatted file on dist, throws error when already exits</span></div><div class="line">    <span class="comment">// @throws std::ios_base::failure</span></div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">FileId</a> NewFile(<span class="keyword">const</span> <span class="keywordtype">char</span>* path);</div><div class="line"></div><div class="line">    <span class="comment">// Get page from iterator</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    Iterator&lt;T&gt; GetPage(<a class="code" href="struct_generic_i_o_id.html">FileId</a> file_id, <a class="code" href="struct_generic_i_o_id.html">PageId</a> page_id);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// allocate a new page on file</span></div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">PageId</a> AllocatePageAfter(<a class="code" href="struct_generic_i_o_id.html">FileId</a> fid, <a class="code" href="struct_generic_i_o_id.html">PageId</a> prev);</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keywordtype">void</span> IteratorNextPage(Iterator&lt;T&gt; * target);</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keywordtype">void</span> IteratorPrevPage(Iterator&lt;T&gt; * target);</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">PageId</a> IteratorInsertPageAfter(Iterator&lt;T&gt;* target);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> IteratorDeletePage(<a class="code" href="struct_page.html">Page</a>* target);</div><div class="line"></div><div class="line">    <span class="comment">// first loop it up in memory, if failed, find in disk</span></div><div class="line">    <a class="code" href="struct_page.html">Page</a>* AutoFetchPage(UniquePage);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> FlushPageToDisk(<a class="code" href="struct_page.html">Page</a>* page, <a class="code" href="struct_generic_i_o_id.html">PageId</a> pid);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> FlushFileHeaderToDisk(<a class="code" href="struct_generic_i_o_id.html">FileId</a> fid);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> UnloadPage(UniquePage);</div><div class="line"></div><div class="line">    <a class="code" href="struct_page.html">Page</a>* GetEmptyPage(<span class="keywordtype">int</span> prev, <span class="keywordtype">int</span> next);</div><div class="line"></div><div class="line">    <a name="_a46"></a><a class="code" href="struct_page_1_1_header.html">Page::Header</a> GetPageHeader(<a class="code" href="struct_generic_i_o_id.html">FileId</a> fid, <a class="code" href="struct_generic_i_o_id.html">PageId</a> psid);</div><div class="line"></div><div class="line">    ~<a class="code" href="class_buffer_manager.html">BufferManager</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> DeletePage(<a class="code" href="struct_page.html">Page</a>*);</div><div class="line"></div><div class="line">    std::map&lt;fs::path, FileId&gt; loaded_files_;</div><div class="line">    std::vector&lt;FileInfo&gt; file_infos_;</div><div class="line"></div><div class="line">    std::map&lt;UniquePage, Page*&gt; pages_;</div><div class="line">    </div><div class="line">    <span class="keywordtype">int</span> max_pages_ = 32;</div><div class="line">    <span class="keywordtype">int</span> num_allocate_disk_page_ = 4;</div><div class="line"></div><div class="line">    <a class="code" href="struct_page.html">Page</a>* empty_page_ = <span class="keyword">nullptr</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// variadic parameter</span></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">class </span><a name="_a47"></a><a class="code" href="class_buffer_manager_1_1_iterator.html">BufferManager::Iterator</a>&lt;char*&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> pointer = <span class="keywordtype">char</span>*;</div><div class="line">    Iterator(<span class="keywordtype">char</span>* current, <a class="code" href="struct_page.html">Page</a>* <a class="code" href="class_buffer_manager_1_1_iterator.html#a5a17d8377bc10f437e29b058c0376b15">page</a>, <a class="code" href="class_buffer_manager.html">BufferManager</a>* boss)</div><div class="line">        :current_(current), page_(<a class="code" href="class_buffer_manager_1_1_iterator.html#a5a17d8377bc10f437e29b058c0376b15">page</a>), boss_(boss), record_in_page_(0) {}</div><div class="line"></div><div class="line">    Iterator(<span class="keywordtype">char</span>* current, <a class="code" href="struct_page.html">Page</a>* <a class="code" href="class_buffer_manager_1_1_iterator.html#a5a17d8377bc10f437e29b058c0376b15">page</a>, <a class="code" href="class_buffer_manager.html">BufferManager</a>* boss, uint16_t record_in_page)</div><div class="line">        :current_(current), page_(<a class="code" href="class_buffer_manager_1_1_iterator.html#a5a17d8377bc10f437e29b058c0376b15">page</a>), boss_(boss), record_in_page_(record_in_page) {}</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="class_buffer_manager_1_1_iterator.html#ad19030c51bf30e6d6e9e2e560cc511c4">IsNil</a>()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> GetDataPos().offset == Page::kInValidOffset;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="class_buffer_manager_1_1_iterator.html#a02a38a84fd54e45d06818d2807b172d8">IsEnd</a>()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="class_buffer_manager_1_1_iterator.html#a6afaceac9683f05d9e1ecfc9ff5f3a0f">IsEndPage</a>()  <span class="comment">// we reach end of the page</span></div><div class="line">            &amp;&amp; !page_-&gt;HasNext(); <span class="comment">// and page does not have any nexts</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="class_buffer_manager_1_1_iterator.html#a6afaceac9683f05d9e1ecfc9ff5f3a0f">IsEndPage</a>()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> (record_in_page_ == page_-&gt;header.num_records);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="class_buffer_manager_1_1_iterator.html#a7ce4145bd6263f8003c4c4dee01a9c31">IsBegin</a>()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> (record_in_page_ == 0)  <span class="comment">// we reach end of the page</span></div><div class="line">            &amp;&amp; !page_-&gt;HasPrev(); <span class="comment">// and page does not have any prevs</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//TODO(L) Assert</span></div><div class="line">    <span class="keywordtype">char</span>* <a class="code" href="class_buffer_manager_1_1_iterator.html#a633c54abf71a334ff179cc359e655d5d">operator*</a>() { <span class="keywordflow">return</span> current_; }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="class_buffer_manager_1_1_iterator.html#a633c54abf71a334ff179cc359e655d5d">operator*</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> current_; }</div><div class="line"></div><div class="line">    Iterator&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#aabf5af4d55b46c14bddff0e7caab3665">operator++</a>(); <span class="comment">// prefix</span></div><div class="line"></div><div class="line">    [[deprecated(<span class="stringliteral">&quot;Please use prefix version as this is less efficient&quot;</span>)]]</div><div class="line">    Iterator <a class="code" href="class_buffer_manager_1_1_iterator.html#aabf5af4d55b46c14bddff0e7caab3665">operator++</a>(<span class="keywordtype">int</span>); <span class="comment">// postfix</span></div><div class="line"></div><div class="line">    Iterator&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#ab9959f549dcfa3f6daa47677552b673d">operator--</a>();</div><div class="line"></div><div class="line">    [[deprecated(<span class="stringliteral">&quot;Please use prefix version as this is less efficient&quot;</span>)]]</div><div class="line">    Iterator <a class="code" href="class_buffer_manager_1_1_iterator.html#ab9959f549dcfa3f6daa47677552b673d">operator--</a>(<span class="keywordtype">int</span>);</div><div class="line"></div><div class="line">    <span class="comment">// use template version</span></div><div class="line">    <span class="keyword">const</span> Iterator&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#aced12f95569a91d98a83bf635d671e25">operator+=</a>(<span class="keywordtype">int</span> offset);</div><div class="line"></div><div class="line">    <span class="comment">// use template version</span></div><div class="line">    <span class="keyword">const</span> Iterator&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#a2a24e019d3a2934f3cd275b8a2436e59">operator-=</a>(<span class="keywordtype">int</span> offset);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="struct_page.html">Page</a>&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#a5a17d8377bc10f437e29b058c0376b15">page</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *page_; }</div><div class="line"></div><div class="line">    std::string AsString() {</div><div class="line">        <span class="keywordflow">return</span> std::string(current_, GetDataPos().length);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// actually this insert one data</span></div><div class="line">    <span class="keywordtype">bool</span> Insert(<span class="keyword">const</span> <span class="keywordtype">char</span>* first, <span class="keyword">const</span> <span class="keywordtype">char</span>* last) {</div><div class="line">        uint16_t num_elem = static_cast&lt;uint16_t&gt;(last - first);</div><div class="line">        uint16_t rounded = RoundUpByte(num_elem);</div><div class="line">        <span class="keywordflow">if</span> (num_elem &gt; <a class="code" href="class_buffer_manager_1_1_iterator.html#a3a53f35f35074aa2079dead6cc606a5b">FreeBytes</a>()) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordtype">size_t</span> size_moved = page_-&gt;header.free_offset - (current_ - page_-&gt;space);</div><div class="line"></div><div class="line">        page_-&gt;header.free_offset += rounded;</div><div class="line">        memmove(current_ + rounded, current_, size_moved);</div><div class="line">        memmove(current_, first, num_elem);</div><div class="line">        </div><div class="line"></div><div class="line">        <a name="_a48"></a><a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a> pos;</div><div class="line"></div><div class="line">        pos.<a name="a49"></a>offset = static_cast&lt;uint16_t&gt;(current_ - page_-&gt;space);</div><div class="line">        pos.<a name="a50"></a>length = num_elem;</div><div class="line">        page_-&gt;ReverseInsertN&lt;<a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&gt;(record_in_page_, 1, page_-&gt;header.num_records - record_in_page_, pos);</div><div class="line"></div><div class="line">        <a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a> last_pos;</div><div class="line">        Iterator <span class="keyword">self</span>(*this);</div><div class="line">        ++page_-&gt;header.num_records;</div><div class="line">        <span class="keywordflow">for</span> (++<span class="keyword">self</span>; !<span class="keyword">self</span>.IsEndPage(); ++<span class="keyword">self</span>) {</div><div class="line">            last_pos = <span class="keyword">self</span>.GetDataPos();</div><div class="line">            last_pos.offset += rounded;</div><div class="line"></div><div class="line">            <span class="keyword">self</span>.GetDataPos() = pos;</div><div class="line"></div><div class="line">            pos = last_pos;</div><div class="line">        }</div><div class="line"></div><div class="line">        page_-&gt;is_dirty = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> Insert(<span class="keyword">const</span> std::string&amp; str) {</div><div class="line">        <span class="keywordflow">return</span> Insert(str.c_str(), str.c_str() + str.size());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> Insert(<span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">size_t</span> length_by_bytes) {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* cdata = reinterpret_cast&lt;const char*&gt;(data);</div><div class="line">        <span class="keywordflow">return</span> Insert(cdata, cdata + length_by_bytes);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> <a class="code" href="class_buffer_manager_1_1_iterator.html#a3a53f35f35074aa2079dead6cc606a5b">FreeBytes</a>()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> page_-&gt;SpaceLeftByByteVariadicSize();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    T RoundUpByte(T <span class="keywordtype">byte</span>) {</div><div class="line">        <span class="keywordflow">return</span> (<span class="keywordtype">byte</span> + 7) / 8 * 8;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="class_buffer_manager_1_1_iterator.html#aee5637c96ddb7c5fef0f9a12d133c7c8">InsertNil</a>(<span class="keywordtype">int</span> n) {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="class_buffer_manager_1_1_iterator.html#a3a53f35f35074aa2079dead6cc606a5b">FreeBytes</a>() / <span class="keyword">sizeof</span>(<a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>) &lt; n) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordtype">size_t</span> n_moved = page_-&gt;header.num_records - record_in_page_;</div><div class="line">        <a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a> pos;</div><div class="line">        pos.offset = Page::kInValidOffset;</div><div class="line">        pos.length = 0;</div><div class="line">        page_-&gt;ReverseInsertN&lt;<a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&gt;(record_in_page_, n, n_moved, pos);</div><div class="line">        page_-&gt;header.num_records += n;</div><div class="line">        page_-&gt;is_dirty = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">PageId</a> AutoInsert(<span class="keyword">const</span> <span class="keywordtype">char</span>* first, <span class="keyword">const</span> <span class="keywordtype">char</span>* last) {</div><div class="line">        <span class="keywordflow">if</span> (!Insert(first, last)) {</div><div class="line">            <span class="keyword">auto</span> piggy = reinterpret_cast&lt;PagePiggyback*&gt;(page_-&gt;piggyback);</div><div class="line">            <a class="code" href="struct_generic_i_o_id.html">PageId</a> next = boss_-&gt;AllocatePageAfter(piggy-&gt;finfo-&gt;id, piggy-&gt;page_id);</div><div class="line">            *<span class="keyword">this</span> = boss_-&gt;GetPage&lt;<span class="keywordtype">char</span>*&gt;(piggy-&gt;finfo-&gt;id, next);</div><div class="line">            <span class="keywordflow">if</span> (!Insert(first, last)) {</div><div class="line">                <span class="keywordflow">throw</span> std::overflow_error(<span class="stringliteral">&quot;The string is too long&quot;</span>);</div><div class="line">            }</div><div class="line">            <span class="comment">// page_-&gt;is_dirty = true;</span></div><div class="line">            ++* <span class="keyword">this</span>;</div><div class="line">            <span class="keywordflow">return</span> next;</div><div class="line">        }</div><div class="line"></div><div class="line">        ++* <span class="keyword">this</span>;</div><div class="line">        <span class="comment">// page_-&gt;is_dirty = true;</span></div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="struct_generic_i_o_id.html">PageId</a>();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">PageId</a> AutoInsert(<span class="keyword">const</span> std::string&amp; str) {</div><div class="line">        <span class="keywordflow">return</span> AutoInsert(str.c_str(), str.c_str() + str.size() + 1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="class_buffer_manager_1_1_iterator.html#a2c627998f19999fe55b7452b840ce47b">EraseInPage</a>(<span class="keywordtype">size_t</span> n = 1) {</div><div class="line">        Iterator <span class="keyword">self</span> = *<span class="keyword">this</span>;</div><div class="line">        <span class="keywordflow">if</span> (page_-&gt;header.num_records - record_in_page_ &lt; n) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        uint16_t length = GetDataPos(record_in_page_ + n).offset + GetDataPos(record_in_page_ + n).length - GetDataPos().offset;</div><div class="line">        int32_t n_moved = page_-&gt;header.free_offset - length;</div><div class="line">        <span class="keywordflow">if</span> (n_moved &lt;= 0) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        page_-&gt;header.free_offset -= length;</div><div class="line">        memmove(current_, current_ + length, n_moved);</div><div class="line">            </div><div class="line">        page_-&gt;ReverseEraseN&lt;<a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&gt;(record_in_page_, n, n_moved);</div><div class="line">        page_-&gt;header.num_records -= n;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="class_buffer_manager_1_1_iterator.html#a2e9a59db2ef1289b16469750e422edd5">DeletePage</a>();</div><div class="line"></div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">PageId</a> AutoInsert(<span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">size_t</span> length_by_bytes) {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* cdata = reinterpret_cast&lt;const char*&gt;(data);</div><div class="line">        <span class="keywordflow">return</span> AutoInsert(cdata, cdata + length_by_bytes);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> SkipEndPageNext() {</div><div class="line">        ++* <span class="keyword">this</span>;</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="class_buffer_manager_1_1_iterator.html#a6afaceac9683f05d9e1ecfc9ff5f3a0f">IsEndPage</a>()) {</div><div class="line">            ++* <span class="keyword">this</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    T Read() {</div><div class="line">        <span class="keywordflow">if</span> (GetDataPos().length != <span class="keyword">sizeof</span>(T)) {</div><div class="line">            <span class="keywordtype">size_t</span> len = GetDataPos().length;</div><div class="line">            <span class="keywordtype">size_t</span> sizeT = <span class="keyword">sizeof</span>(T);</div><div class="line">            <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;size of the data mismatch what is written in&quot;</span>);</div><div class="line">        }</div><div class="line">        T res =  *reinterpret_cast&lt;T*&gt;(current_);</div><div class="line">        SkipEndPageNext();</div><div class="line">        <span class="keywordflow">return</span> res;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;&gt;</div><div class="line">    std::string Read() {</div><div class="line">        std::string str(current_, GetDataPos().length);</div><div class="line">        SkipEndPageNext();</div><div class="line">        <span class="keywordflow">return</span> str;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// these are used for others</span></div><div class="line">    <span class="comment">/*Iterator(Variadic* current, Page* page, BufferManager* boss)</span></div><div class="line"><span class="comment">        :current_((char*)current), page_(page), boss_(boss), record_in_page_(0) {}</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    Iterator(Variadic* current, Page* page, BufferManager* boss, uint16_t record_in_page)</span></div><div class="line"><span class="comment">        :current_((char*)current), page_(page), boss_(boss), record_in_page_(record_in_page) {}*/</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&amp; GetDataPos()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> page_-&gt;ReverseRead&lt;<a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&gt;(record_in_page_); }</div><div class="line">    <a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&amp; GetDataPos() { <span class="keywordflow">return</span> page_-&gt;ReverseRead&lt;<a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&gt;(record_in_page_); }</div><div class="line">    <a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&amp; GetDataPos(<span class="keywordtype">size_t</span> num) { <span class="keywordflow">return</span> page_-&gt;ReverseRead&lt;<a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&gt;(num); }</div><div class="line"></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="class_buffer_manager.html">BufferManager</a>;</div><div class="line">    <span class="keywordtype">char</span>* current_;</div><div class="line">    <a class="code" href="struct_page.html">Page</a>* page_;</div><div class="line">    <a class="code" href="class_buffer_manager.html">BufferManager</a>* boss_;</div><div class="line">    uint16_t record_in_page_;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <a class="code" href="struct_generic_i_o_id.html">PageId</a> <a class="code" href="class_buffer_manager_1_1_iterator.html#affb973bacb2deef1704e20221fb3c3fb">BufferManager::Iterator&lt;T&gt;::InsertPageAfter</a>() {</div><div class="line">    <span class="keywordflow">return</span> boss_-&gt;IteratorInsertPageAfter&lt;T&gt;(<span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <a class="code" href="class_buffer_manager_1_1_iterator.html">BufferManager::Iterator&lt;T&gt;</a>&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#aabf5af4d55b46c14bddff0e7caab3665">BufferManager::Iterator&lt;T&gt;::operator++</a>() {</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (record_in_page_ &lt; page_-&gt;header.num_records) {</div><div class="line">        <span class="keywordflow">if</span> (!IsNil()) {</div><div class="line">            ++current_;</div><div class="line">        }</div><div class="line">        ++record_in_page_;</div><div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// reach the end of linked list</span></div><div class="line">    <span class="keywordflow">if</span> (!page_-&gt;HasNext()) {</div><div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    boss_-&gt;IteratorNextPage(<span class="keyword">this</span>);</div><div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">inline</span> <a name="_a51"></a><a class="code" href="class_buffer_manager_1_1_iterator_3_01char_01_5_01_4.html">BufferManager::Iterator&lt;char*&gt;</a>&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#aabf5af4d55b46c14bddff0e7caab3665">BufferManager::Iterator&lt;char*&gt;::operator++</a>() {</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (record_in_page_ &lt; page_-&gt;header.num_records) {</div><div class="line">        ++record_in_page_;</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="class_buffer_manager_1_1_iterator.html#a6afaceac9683f05d9e1ecfc9ff5f3a0f">IsEndPage</a>()) {</div><div class="line">            <span class="keyword">auto</span> length = page_-&gt;ReverseRead&lt;<a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&gt;(record_in_page_ - 1).length;</div><div class="line">            current_ += RoundUpByte(length);</div><div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (!<a class="code" href="class_buffer_manager_1_1_iterator.html#ad19030c51bf30e6d6e9e2e560cc511c4">IsNil</a>()) {</div><div class="line">            current_ = page_-&gt;space + page_-&gt;ReverseRead&lt;<a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&gt;(record_in_page_).offset;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// reach the end of linked list</span></div><div class="line">    <span class="keywordflow">if</span> (!page_-&gt;HasNext()) {</div><div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    boss_-&gt;<a name="a52"></a>IteratorNextPage(<span class="keyword">this</span>);</div><div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <a class="code" href="class_buffer_manager_1_1_iterator.html">BufferManager::Iterator&lt;T&gt;</a> <a class="code" href="class_buffer_manager_1_1_iterator.html#aabf5af4d55b46c14bddff0e7caab3665">BufferManager::Iterator&lt;T&gt;::operator++</a>(<span class="keywordtype">int</span>)</div><div class="line">{</div><div class="line">    Iterator <span class="keyword">self</span> = *<span class="keyword">this</span>;</div><div class="line">    ++* <span class="keyword">this</span>;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">self</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <a class="code" href="class_buffer_manager_1_1_iterator.html">BufferManager::Iterator&lt;T&gt;</a>&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#ab9959f549dcfa3f6daa47677552b673d">BufferManager::Iterator&lt;T&gt;::operator--</a>()</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (record_in_page_ == 0) {</div><div class="line">        <span class="comment">// reach the end of linked list</span></div><div class="line">        <span class="keywordflow">if</span> (!page_-&gt;HasPrev()) {</div><div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">        }</div><div class="line">        boss_-&gt;IteratorPrevPage(<span class="keyword">this</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    --record_in_page_;</div><div class="line">    <span class="keywordflow">if</span> (!IsNil()) {</div><div class="line">        --current_;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <a class="code" href="class_buffer_manager_1_1_iterator_3_01char_01_5_01_4.html">BufferManager::Iterator&lt;char*&gt;</a>&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#ab9959f549dcfa3f6daa47677552b673d">BufferManager::Iterator&lt;char*&gt;::operator--</a>()</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (record_in_page_ == 0) {</div><div class="line">        <span class="comment">// reach the end of linked list</span></div><div class="line">        <span class="keywordflow">if</span> (!page_-&gt;HasPrev()) {</div><div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">        }</div><div class="line">        boss_-&gt;IteratorPrevPage(<span class="keyword">this</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    --record_in_page_;</div><div class="line">    <span class="keywordflow">if</span> (!IsNil()) {</div><div class="line">        current_ = page_-&gt;space + page_-&gt;ReverseRead&lt;<a class="code" href="struct_page_1_1_data_pos.html">Page::DataPos</a>&gt;(record_in_page_).offset;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <a class="code" href="class_buffer_manager_1_1_iterator.html">BufferManager::Iterator&lt;T&gt;</a> <a class="code" href="class_buffer_manager_1_1_iterator.html#ab9959f549dcfa3f6daa47677552b673d">BufferManager::Iterator&lt;T&gt;::operator--</a>(<span class="keywordtype">int</span>)</div><div class="line">{</div><div class="line">    Iterator <span class="keyword">self</span> = *<span class="keyword">this</span>;</div><div class="line">    --* <span class="keyword">this</span>;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">self</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="class_buffer_manager_1_1_iterator.html">BufferManager::Iterator&lt;T&gt;</a>&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#aced12f95569a91d98a83bf635d671e25">BufferManager::Iterator&lt;T&gt;::operator+=</a>(<span class="keywordtype">int</span> offset)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (offset &lt; 0) {</div><div class="line">        <span class="keywordflow">return</span> operator-=(-offset);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> num_left = page_-&gt;header.num_records - record_in_page_;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (offset &lt;= num_left) {</div><div class="line">        <span class="keywordflow">for</span> (; offset &gt; 0; --offset) {</div><div class="line">            ++* <span class="keyword">this</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    offset -= num_left;</div><div class="line">    <span class="keywordtype">int</span> last_offset = offset;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (offset &gt; 0) {</div><div class="line">        <span class="keyword">auto</span> piggy = reinterpret_cast&lt;PagePiggyback*&gt;(page_-&gt;piggyback);</div><div class="line">        <a class="code" href="struct_generic_i_o_id.html">PageId</a> cpage = piggy-&gt;page_id + page_-&gt;header.next;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (!page_-&gt;HasNext()) {</div><div class="line">            current_ = reinterpret_cast&lt;pointer&gt;(page_-&gt;header.free_offset + page_-&gt;space);</div><div class="line">            record_in_page_ = page_-&gt;header.num_records;</div><div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        cpage.id += page_-&gt;header.next;</div><div class="line">        *<span class="keyword">this</span> = boss_-&gt;GetPage&lt;T&gt;(piggy-&gt;finfo-&gt;id, cpage);</div><div class="line"></div><div class="line">        last_offset = offset;</div><div class="line">        </div><div class="line">        offset -= page_-&gt;header.num_records;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> operator+=(last_offset);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="class_buffer_manager_1_1_iterator.html">BufferManager::Iterator&lt;T&gt;</a>&amp; <a class="code" href="class_buffer_manager_1_1_iterator.html#a2a24e019d3a2934f3cd275b8a2436e59">BufferManager::Iterator&lt;T&gt;::operator-=</a>(<span class="keywordtype">int</span> offset)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (offset &lt; 0) {</div><div class="line">        <span class="keywordflow">return</span> operator+=(-offset);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> num_left = record_in_page_;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (offset &lt; record_in_page_) {</div><div class="line">        <span class="keywordflow">for</span> (; offset &gt; 0; --offset) {</div><div class="line">            --* <span class="keyword">this</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    offset -= num_left;</div><div class="line">    <span class="keywordtype">int</span> last_offset = offset;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (offset &gt; 0)</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> piggy = reinterpret_cast&lt;PagePiggyback*&gt;(page_-&gt;piggyback);</div><div class="line">        <a class="code" href="struct_generic_i_o_id.html">PageId</a> cpage = piggy-&gt;page_id;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (!page_-&gt;HasPrev()) {</div><div class="line">            current_ = reinterpret_cast&lt;pointer&gt;(page_-&gt;space);</div><div class="line">            record_in_page_ = 0;</div><div class="line">            <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        cpage.id += page_-&gt;header.prev;</div><div class="line">        *<span class="keyword">this</span> = boss_-&gt;GetPage&lt;T&gt;(piggy-&gt;finfo-&gt;id, cpage);</div><div class="line"></div><div class="line">        last_offset = offset;</div><div class="line">        offset -= num_left;</div><div class="line"></div><div class="line">        num_left = page_-&gt;header.num_records;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> operator-=(last_offset);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <a class="code" href="struct_generic_i_o_id.html">PageId</a> <a class="code" href="class_buffer_manager_1_1_iterator.html#a7a57002c7f8daa714cf9e19e34874fca">BufferManager::Iterator&lt;T&gt;::pageid</a>()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keyword">auto</span> piggy = reinterpret_cast&lt;PagePiggyback*&gt;(page_-&gt;piggyback);</div><div class="line">    <span class="keywordflow">return</span> piggy-&gt;page_id;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="class_buffer_manager_1_1_iterator.html#a2e9a59db2ef1289b16469750e422edd5">BufferManager::Iterator&lt;T&gt;::DeletePage</a>() {</div><div class="line">    boss_-&gt;IteratorDeletePage(page_);</div><div class="line">    page_ = <span class="keyword">nullptr</span>;</div><div class="line">    record_in_page_ = 0;</div><div class="line">    current_ = <span class="keyword">nullptr</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <a class="code" href="class_buffer_manager_1_1_iterator.html">BufferManager::Iterator&lt;T&gt;</a> BufferManager::GetPage(<a class="code" href="struct_generic_i_o_id.html">FileId</a> file_id, <a class="code" href="struct_generic_i_o_id.html">PageId</a> page_id)</div><div class="line">{</div><div class="line">    UniquePage unipage{ page_id, file_id };</div><div class="line">    <a class="code" href="struct_page.html">Page</a>* page = AutoFetchPage(unipage);</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> Iterator&lt;T&gt;(<span class="keyword">reinterpret_cast&lt;</span>typename Iterator&lt;T&gt;::pointer<span class="keyword">&gt;</span>(page-&gt;space), page, <span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> BufferManager::IteratorNextPage(Iterator&lt;T&gt;* target)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span>&amp; page = target-&gt;page();</div><div class="line">    <span class="keyword">auto</span> piggy = static_cast&lt;const PagePiggyback*&gt;(page.piggyback);</div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">PageId</a> target_page = piggy-&gt;page_id;</div><div class="line"></div><div class="line">    target_page.id += page.header.next;</div><div class="line"></div><div class="line">    (*target) = GetPage&lt;T&gt;(piggy-&gt;finfo-&gt;id, target_page);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> BufferManager::IteratorPrevPage(Iterator&lt;T&gt;* target)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span>&amp; page = target-&gt;page();</div><div class="line">    <span class="keyword">auto</span> piggy = static_cast&lt;const PagePiggyback*&gt;(page.piggyback);</div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">PageId</a> target_page = piggy-&gt;page_id;</div><div class="line"></div><div class="line">    target_page.id += page.header.prev;</div><div class="line">    (*target) = GetPage&lt;T&gt;(piggy-&gt;finfo-&gt;id, target_page);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <a class="code" href="struct_generic_i_o_id.html">PageId</a> BufferManager::IteratorInsertPageAfter(Iterator&lt;T&gt;* target)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> piggy = static_cast&lt;PagePiggyback*&gt;(target-&gt;page().piggyback);</div><div class="line">    <a class="code" href="struct_generic_i_o_id.html">FileId</a> fid = piggy-&gt;finfo-&gt;id;</div><div class="line">    <span class="keywordflow">return</span> AllocatePageAfter(fid, piggy-&gt;page_id);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#if 0</span></div><div class="line"><span class="comment">// obsolete code, may come useful some time</span></div><div class="line">    <span class="keywordtype">void</span> ReverseShiftBits(<span class="keywordtype">int</span> dst, <span class="keywordtype">int</span> src, <span class="keywordtype">size_t</span> num_bits) {</div><div class="line">        <span class="keywordtype">int</span> shift = ;</div><div class="line">        <span class="keywordtype">int</span> end_dst = (dst + num_bits) / 8 + 1;</div><div class="line">        <span class="keywordtype">int</span> end_src = (src + num_bits) / 8 + 1;</div><div class="line">        <span class="keywordtype">int</span> beg_src = src / 8 + 1;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> carry = 0;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* tail = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)end());</div><div class="line">        <span class="keywordflow">for</span> (; end_src != beg_src;) {</div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _byte = tail[-end_src];</div><div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> old_carry = carry;</div><div class="line">            carry = _byte &lt;&lt; shift;</div><div class="line">            _byte &gt;&gt; (8 - shift);</div><div class="line">            tail[-end_dst] = _byte | old_carry;</div><div class="line"></div><div class="line">            --end_src;</div><div class="line">            --end_dst;</div><div class="line">        }</div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
